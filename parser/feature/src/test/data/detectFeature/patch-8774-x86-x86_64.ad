@@ -338,19 +338,11 @@ extern RegMask _FLOAT_REG_mask;
 
 extern RegMask _STACK_OR_PTR_REG_mask;
 extern RegMask _STACK_OR_LONG_REG_mask;
-extern RegMask _STACK_OR_LONG_NO_RAX_RDX_REG_mask;
 extern RegMask _STACK_OR_INT_REG_mask;
-extern RegMask _STACK_OR_INT_NO_RAX_RDX_REG_mask;
 
 inline const RegMask& STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
 inline const RegMask& STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
-inline const RegMask& STACK_OR_LONG_NO_RAX_RDX_REG_mask() {
-  return _STACK_OR_LONG_NO_RAX_RDX_REG_mask;
-}
 inline const RegMask& STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
-inline const RegMask& STACK_OR_INT_NO_RAX_RDX_REG_mask() {
-  return _STACK_OR_INT_NO_RAX_RDX_REG_mask;
-}
 
 %}
 
@@ -376,9 +368,7 @@ RegMask _INT_NO_RBP_R13_REG_mask;
 RegMask _FLOAT_REG_mask;
 RegMask _STACK_OR_PTR_REG_mask;
 RegMask _STACK_OR_LONG_REG_mask;
-RegMask _STACK_OR_LONG_NO_RAX_RDX_REG_mask;
 RegMask _STACK_OR_INT_REG_mask;
-RegMask _STACK_OR_INT_NO_RAX_RDX_REG_mask;
 
 static bool need_r12_heapbase() {
   return UseCompressedOops;
@@ -439,9 +429,6 @@ void reg_mask_init() {
   _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));
   _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));
 
-  _STACK_OR_LONG_NO_RAX_RDX_REG_mask = _LONG_NO_RAX_RDX_REG_mask;
-  _STACK_OR_LONG_NO_RAX_RDX_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
-
   _INT_REG_mask = _ALL_INT_REG_mask;
   if (PreserveFramePointer) {
     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));
@@ -464,9 +451,6 @@ void reg_mask_init() {
   _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));
   _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));
 
-  _STACK_OR_INT_NO_RAX_RDX_REG_mask = _INT_NO_RAX_RDX_REG_mask;
-  _STACK_OR_INT_NO_RAX_RDX_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
-
   // _FLOAT_REG_LEGACY_mask/_FLOAT_REG_EVEX_mask is generated by adlc
   // from the float_reg_legacy/float_reg_evex register class.
   _FLOAT_REG_mask = VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask;
@@ -1923,6 +1907,123 @@ encode %{
     emit_rm(cbuf, 0x3, $dst$$reg & 7, $src$$reg & 7);
   %}
 
+  enc_class cdql_enc(no_rax_rdx_RegI div)
+  %{
+    // Full implementation of Java idiv and irem; checks for
+    // special case as described in JVM spec., p.243 & p.271.
+    //
+    //         normal case                           special case
+    //
+    // input : rax: dividend                         min_int
+    //         reg: divisor                          -1
+    //
+    // output: rax: quotient  (= rax idiv reg)       min_int
+    //         rdx: remainder (= rax irem reg)       0
+    //
+    //  Code sequnce:
+    //
+    //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
+    //    5:   75 07/08                jne    e <normal>
+    //    7:   33 d2                   xor    %edx,%edx
+    //  [div >= 8 -> offset + 1]
+    //  [REX_B]
+    //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
+    //    c:   74 03/04                je     11 <done>
+    // 000000000000000e <normal>:
+    //    e:   99                      cltd
+    //  [div >= 8 -> offset + 1]
+    //  [REX_B]
+    //    f:   f7 f9                   idiv   $div
+    // 0000000000000011 <done>:
+    MacroAssembler _masm(&cbuf);
+    Label normal;
+    Label done;
+
+    // cmp    $0x80000000,%eax
+    __ cmpl(as_Register(RAX_enc), 0x80000000);
+
+    // jne    e <normal>
+    __ jccb(Assembler::notEqual, normal);
+
+    // xor    %edx,%edx
+    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));
+
+    // cmp    $0xffffffffffffffff,%ecx
+    __ cmpl($div$$Register, -1);
+
+    // je     11 <done>
+    __ jccb(Assembler::equal, done);
+
+    // <normal>
+    // cltd
+    __ bind(normal);
+    __ cdql();
+
+    // idivl
+    // <done>
+    __ idivl($div$$Register);
+    __ bind(done);
+  %}
+
+  enc_class cdqq_enc(no_rax_rdx_RegL div)
+  %{
+    // Full implementation of Java ldiv and lrem; checks for
+    // special case as described in JVM spec., p.243 & p.271.
+    //
+    //         normal case                           special case
+    //
+    // input : rax: dividend                         min_long
+    //         reg: divisor                          -1
+    //
+    // output: rax: quotient  (= rax idiv reg)       min_long
+    //         rdx: remainder (= rax irem reg)       0
+    //
+    //  Code sequnce:
+    //
+    //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
+    //    7:   00 00 80
+    //    a:   48 39 d0                cmp    %rdx,%rax
+    //    d:   75 08                   jne    17 <normal>
+    //    f:   33 d2                   xor    %edx,%edx
+    //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
+    //   15:   74 05                   je     1c <done>
+    // 0000000000000017 <normal>:
+    //   17:   48 99                   cqto
+    //   19:   48 f7 f9                idiv   $div
+    // 000000000000001c <done>:
+    MacroAssembler _masm(&cbuf);
+    Label normal;
+    Label done;
+
+    // mov    $0x8000000000000000,%rdx
+    __ mov64(as_Register(RDX_enc), 0x8000000000000000);
+
+    // cmp    %rdx,%rax
+    __ cmpq(as_Register(RAX_enc), as_Register(RDX_enc));
+
+    // jne    17 <normal>
+    __ jccb(Assembler::notEqual, normal);
+
+    // xor    %edx,%edx
+    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));
+
+    // cmp    $0xffffffffffffffff,$div
+    __ cmpq($div$$Register, -1);
+
+    // je     1e <done>
+    __ jccb(Assembler::equal, done);
+
+    // <normal>
+    // cqto
+    __ bind(normal);
+    __ cdqq();
+
+    // idivq (note: must be emitted by the user of this rule)
+    // <done>
+    __ idivq($div$$Register);
+    __ bind(done);
+  %}
+
   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
   enc_class OpcSE(immI imm)
   %{
@@ -8523,65 +8624,40 @@ instruct umulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
                    rFlagsReg cr)
 %{
-  match(Set rax (NoOvfDivI rax div));
-  effect(KILL rdx, KILL cr);
-
-  ins_cost(500);
-  format %{ "cdql\n\t"
-            "idivl   $div" %}
-  ins_encode %{
-    __ cdql();
-    __ idivl($div$$Register);
-  %}
-  ins_pipe(pipe_slow);
-%}
-
-instruct divI_mem(rax_RegI rax, rdx_RegI rdx, memory div,
-                   rFlagsReg cr)
-%{
-  match(Set rax (NoOvfDivI rax (LoadI div)));
+  match(Set rax (DivI rax div));
   effect(KILL rdx, KILL cr);
 
-  ins_cost(575);
-  format %{ "cdql\n\t"
-            "idivl   $div" %}
-  ins_encode %{
-    __ cdql();
-    __ idivl($div$$Address);
-  %}
-  ins_pipe(pipe_slow);
+  ins_cost(30*100+10*100); // XXX
+  format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
+            "jne,s   normal\n\t"
+            "xorl    rdx, rdx\n\t"
+            "cmpl    $div, -1\n\t"
+            "je,s    done\n"
+    "normal: cdql\n\t"
+            "idivl   $div\n"
+    "done:"        %}
+  ins_encode(cdql_enc(div));
+  ins_pipe(ialu_reg_reg_alu0);
 %}
 
 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
                    rFlagsReg cr)
 %{
-  match(Set rax (NoOvfDivL rax div));
-  effect(KILL rdx, KILL cr);
-
-  ins_cost(500);
-  format %{ "cdqq\n\t"
-            "idivq   $div" %}
-  ins_encode %{
-    __ cdqq();
-    __ idivq($div$$Register);
-  %}
-  ins_pipe(pipe_slow);
-%}
-
-instruct divL_mem(rax_RegL rax, rdx_RegL rdx, memory div,
-                   rFlagsReg cr)
-%{
-  match(Set rax (NoOvfDivL rax (LoadL div)));
+  match(Set rax (DivL rax div));
   effect(KILL rdx, KILL cr);
 
-  ins_cost(575);
-  format %{ "cdqq\n\t"
-            "idivq   $div" %}
-  ins_encode %{
-    __ cdqq();
-    __ idivq($div$$Address);
-  %}
-  ins_pipe(pipe_slow);
+  ins_cost(30*100+10*100); // XXX
+  format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
+            "cmpq    rax, rdx\n\t"
+            "jne,s   normal\n\t"
+            "xorl    rdx, rdx\n\t"
+            "cmpq    $div, -1\n\t"
+            "je,s    done\n"
+    "normal: cdqq\n\t"
+            "idivq   $div\n"
+    "done:"        %}
+  ins_encode(cdqq_enc(div));
+  ins_pipe(ialu_reg_reg_alu0);
 %}
 
 instruct udivI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div, rFlagsReg cr)
@@ -8614,33 +8690,40 @@ instruct udivL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div, rFlagsReg c
 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
                              rFlagsReg cr)
 %{
-  match(NoOvfDivModI rax div);
+  match(DivModI rax div);
   effect(KILL cr);
 
-  ins_cost(500);
-  format %{ "cdql\n\t"
-            "idivl   $div" %}
-  ins_encode %{
-    __ cdql();
-    __ idivl($div$$Register);
-  %}
+  ins_cost(30*100+10*100); // XXX
+  format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
+            "jne,s   normal\n\t"
+            "xorl    rdx, rdx\n\t"
+            "cmpl    $div, -1\n\t"
+            "je,s    done\n"
+    "normal: cdql\n\t"
+            "idivl   $div\n"
+    "done:"        %}
+  ins_encode(cdql_enc(div));
   ins_pipe(pipe_slow);
 %}
 
 // Long DIVMOD with Register, both quotient and mod results
 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
                              rFlagsReg cr)
 %{
-  match(NoOvfDivModL rax div);
+  match(DivModL rax div);
   effect(KILL cr);
 
-  ins_cost(500);
-  format %{ "cdqq\n\t"
-            "idivq   $div" %}
-  ins_encode %{
-    __ cdqq();
-    __ idivq($div$$Register);
-  %}
+  ins_cost(30*100+10*100); // XXX
+  format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
+            "cmpq    rax, rdx\n\t"
+            "jne,s   normal\n\t"
+            "xorl    rdx, rdx\n\t"
+            "cmpq    $div, -1\n\t"
+            "je,s    done\n"
+    "normal: cdqq\n\t"
+            "idivq   $div\n"
+    "done:"        %}
+  ins_encode(cdqq_enc(div));
   ins_pipe(pipe_slow);
 %}
 
@@ -8678,68 +8761,108 @@ instruct udivModL_rReg_divmod(rax_RegL rax, no_rax_rdx_RegL tmp, rdx_RegL rdx,
   ins_pipe(pipe_slow);
 %}
 
-instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
-                   rFlagsReg cr)
+
+//----------- DivL-By-Constant-Expansions--------------------------------------
+// DivI cases are handled by the compiler
+
+// Magic constant, reciprocal of 10
+instruct loadConL_0x6666666666666667(rRegL dst)
 %{
-  match(Set rdx (NoOvfModI rax div));
-  effect(KILL rax, KILL cr);
+  effect(DEF dst);
+
+  format %{ "movq    $dst, #0x666666666666667\t# Used in div-by-10" %}
+  ins_encode(load_immL(dst, 0x6666666666666667));
+  ins_pipe(ialu_reg);
+%}
+
+instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
+%{
+  effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 
-  ins_cost(500);
-  format %{ "cdql\n\t"
-            "idivl   $div" %}
+  format %{ "imulq   rdx:rax, rax, $src\t# Used in div-by-10" %}
   ins_encode %{
-    __ cdql();
-    __ idivl($div$$Register);
+    __ imulq($src$$Register);
   %}
-  ins_pipe(pipe_slow);
+  ins_pipe(ialu_reg_reg_alu0);
 %}
 
-instruct modI_mem(rdx_RegI rdx, rax_RegI rax, memory div,
-                   rFlagsReg cr)
+instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 %{
-  match(Set rdx (NoOvfModI rax (LoadI div)));
-  effect(KILL rax, KILL cr);
+  effect(USE_DEF dst, KILL cr);
 
-  ins_cost(575);
-  format %{ "cdql\n\t"
-            "idivl   $div" %}
+  format %{ "sarq    $dst, #63\t# Used in div-by-10" %}
   ins_encode %{
-    __ cdql();
-    __ idivl($div$$Address);
+    __ sarq($dst$$Register, 63);
   %}
-  ins_pipe(pipe_slow);
+  ins_pipe(ialu_reg);
 %}
 
-instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
-                   rFlagsReg cr)
+instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 %{
-  match(Set rdx (NoOvfModL rax div));
-  effect(KILL rax, KILL cr);
+  effect(USE_DEF dst, KILL cr);
 
-  ins_cost(500);
-  format %{ "cdqq\n\t"
-            "idivq   $div" %}
+  format %{ "sarq    $dst, #2\t# Used in div-by-10" %}
   ins_encode %{
-    __ cdqq();
-    __ idivq($div$$Register);
+    __ sarq($dst$$Register, 2);
+  %}
+  ins_pipe(ialu_reg);
+%}
+
+instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
+%{
+  match(Set dst (DivL src div));
+
+  ins_cost((5+8)*100);
+  expand %{
+    rax_RegL rax;                     // Killed temp
+    rFlagsReg cr;                     // Killed
+    loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
+    mul_hi(dst, src, rax, cr);        // mulq  rdx:rax <= rax * $src
+    sarL_rReg_63(src, cr);            // sarq  src, 63
+    sarL_rReg_2(dst, cr);             // sarq  rdx, 2
+    subL_rReg(dst, src, cr);          // subl  rdx, src
   %}
-  ins_pipe(pipe_slow);
 %}
 
-instruct modL_mem(rdx_RegL rdx, rax_RegL rax, memory div,
+//-----------------------------------------------------------------------------
+
+instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
                    rFlagsReg cr)
 %{
-  match(Set rdx (NoOvfModL rax (LoadL div)));
+  match(Set rdx (ModI rax div));
   effect(KILL rax, KILL cr);
 
-  ins_cost(575);
-  format %{ "cdqq\n\t"
-            "idivq   $div" %}
-  ins_encode %{
-    __ cdqq();
-    __ idivq($div$$Address);
-  %}
-  ins_pipe(pipe_slow);
+  ins_cost(300); // XXX
+  format %{ "cmpl    rax, 0x80000000\t# irem\n\t"
+            "jne,s   normal\n\t"
+            "xorl    rdx, rdx\n\t"
+            "cmpl    $div, -1\n\t"
+            "je,s    done\n"
+    "normal: cdql\n\t"
+            "idivl   $div\n"
+    "done:"        %}
+  ins_encode(cdql_enc(div));
+  ins_pipe(ialu_reg_reg_alu0);
+%}
+
+instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
+                   rFlagsReg cr)
+%{
+  match(Set rdx (ModL rax div));
+  effect(KILL rax, KILL cr);
+
+  ins_cost(300); // XXX
+  format %{ "movq    rdx, 0x8000000000000000\t# lrem\n\t"
+            "cmpq    rax, rdx\n\t"
+            "jne,s   normal\n\t"
+            "xorl    rdx, rdx\n\t"
+            "cmpq    $div, -1\n\t"
+            "je,s    done\n"
+    "normal: cdqq\n\t"
+            "idivq   $div\n"
+    "done:"        %}
+  ins_encode(cdqq_enc(div));
+  ins_pipe(ialu_reg_reg_alu0);
 %}
 
 instruct umodI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div, rFlagsReg cr)