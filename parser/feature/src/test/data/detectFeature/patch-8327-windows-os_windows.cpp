@@ -4992,43 +4992,6 @@ int os::fsync(int fd) {
   return 0;
 }
 
-static int nonSeekAvailable(int, long *);
-static int stdinAvailable(int, long *);
-
-// This code is a copy of JDK's sysAvailable
-// from src/windows/hpi/src/sys_api_md.c
-
-int os::available(int fd, jlong *bytes) {
-  jlong cur, end;
-  struct _stati64 stbuf64;
-
-  if (::_fstati64(fd, &stbuf64) >= 0) {
-    int mode = stbuf64.st_mode;
-    if (S_ISCHR(mode) || S_ISFIFO(mode)) {
-      int ret;
-      long lpbytes;
-      if (fd == 0) {
-        ret = stdinAvailable(fd, &lpbytes);
-      } else {
-        ret = nonSeekAvailable(fd, &lpbytes);
-      }
-      (*bytes) = (jlong)(lpbytes);
-      return ret;
-    }
-    if ((cur = ::_lseeki64(fd, 0L, SEEK_CUR)) == -1) {
-      return FALSE;
-    } else if ((end = ::_lseeki64(fd, 0L, SEEK_END)) == -1) {
-      return FALSE;
-    } else if (::_lseeki64(fd, cur, SEEK_SET) == -1) {
-      return FALSE;
-    }
-    *bytes = end - cur;
-    return TRUE;
-  } else {
-    return FALSE;
-  }
-}
-
 void os::flockfile(FILE* fp) {
   _lock_file(fp);
 }
@@ -5037,100 +5000,6 @@ void os::funlockfile(FILE* fp) {
   _unlock_file(fp);
 }
 
-// This code is a copy of JDK's nonSeekAvailable
-// from src/windows/hpi/src/sys_api_md.c
-
-static int nonSeekAvailable(int fd, long *pbytes) {
-  // This is used for available on non-seekable devices
-  // (like both named and anonymous pipes, such as pipes
-  //  connected to an exec'd process).
-  // Standard Input is a special case.
-  HANDLE han;
-
-  if ((han = (HANDLE) ::_get_osfhandle(fd)) == (HANDLE)(-1)) {
-    return FALSE;
-  }
-
-  if (! ::PeekNamedPipe(han, NULL, 0, NULL, (LPDWORD)pbytes, NULL)) {
-    // PeekNamedPipe fails when at EOF.  In that case we
-    // simply make *pbytes = 0 which is consistent with the
-    // behavior we get on Solaris when an fd is at EOF.
-    // The only alternative is to raise an Exception,
-    // which isn't really warranted.
-    //
-    if (::GetLastError() != ERROR_BROKEN_PIPE) {
-      return FALSE;
-    }
-    *pbytes = 0;
-  }
-  return TRUE;
-}
-
-#define MAX_INPUT_EVENTS 2000
-
-// This code is a copy of JDK's stdinAvailable
-// from src/windows/hpi/src/sys_api_md.c
-
-static int stdinAvailable(int fd, long *pbytes) {
-  HANDLE han;
-  DWORD numEventsRead = 0;  // Number of events read from buffer
-  DWORD numEvents = 0;      // Number of events in buffer
-  DWORD i = 0;              // Loop index
-  DWORD curLength = 0;      // Position marker
-  DWORD actualLength = 0;   // Number of bytes readable
-  BOOL error = FALSE;       // Error holder
-  INPUT_RECORD *lpBuffer;   // Pointer to records of input events
-
-  if ((han = ::GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE) {
-    return FALSE;
-  }
-
-  // Construct an array of input records in the console buffer
-  error = ::GetNumberOfConsoleInputEvents(han, &numEvents);
-  if (error == 0) {
-    return nonSeekAvailable(fd, pbytes);
-  }
-
-  // lpBuffer must fit into 64K or else PeekConsoleInput fails
-  if (numEvents > MAX_INPUT_EVENTS) {
-    numEvents = MAX_INPUT_EVENTS;
-  }
-
-  lpBuffer = (INPUT_RECORD *)os::malloc(numEvents * sizeof(INPUT_RECORD), mtInternal);
-  if (lpBuffer == NULL) {
-    return FALSE;
-  }
-
-  error = ::PeekConsoleInput(han, lpBuffer, numEvents, &numEventsRead);
-  if (error == 0) {
-    os::free(lpBuffer);
-    return FALSE;
-  }
-
-  // Examine input records for the number of bytes available
-  for (i=0; i<numEvents; i++) {
-    if (lpBuffer[i].EventType == KEY_EVENT) {
-
-      KEY_EVENT_RECORD *keyRecord = (KEY_EVENT_RECORD *)
-                                      &(lpBuffer[i].Event);
-      if (keyRecord->bKeyDown == TRUE) {
-        CHAR *keyPressed = (CHAR *) &(keyRecord->uChar);
-        curLength++;
-        if (*keyPressed == '\r') {
-          actualLength = curLength;
-        }
-      }
-    }
-  }
-
-  if (lpBuffer != NULL) {
-    os::free(lpBuffer);
-  }
-
-  *pbytes = (long) actualLength;
-  return TRUE;
-}
-
 // Map a block of memory.
 char* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,
                         char *addr, size_t bytes, bool read_only,