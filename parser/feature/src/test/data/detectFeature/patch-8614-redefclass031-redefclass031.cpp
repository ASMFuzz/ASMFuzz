@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,12 +39,26 @@ static jvmtiEventCallbacks callbacks;
 static int watch_ev = 0;    /* ignore JVMTI events by default */
 static int gen_ev = 0;      /* number of generated events */
 static int result = PASSED; /* total result of the test */
+static jthread test_thread = NULL;
 
 static jrawMonitorID watch_ev_monitor;
 
-static void set_watch_ev(int value) {
+static void set_watch_ev(JNIEnv *env, int value) {
     jvmti->RawMonitorEnter(watch_ev_monitor);
 
+    if (value) {
+        jvmtiError err = jvmti->GetCurrentThread(&test_thread);
+        if (err != JVMTI_ERROR_NONE) {
+            printf("Failed to get current thread: %s (%d)\n", TranslateError(err), err);
+            result = STATUS_FAILED;
+        } else {
+            test_thread = env->NewGlobalRef(test_thread);
+        }
+    } else if (test_thread != NULL) {
+        env->DeleteGlobalRef(test_thread);
+        test_thread = NULL;
+    }
+
     watch_ev = value;
 
     jvmti->RawMonitorExit(watch_ev_monitor);
@@ -54,9 +68,31 @@ void JNICALL
 NativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr, jmethodID methodID, void * pAddress, void ** pNewAddress) {
     jvmti->RawMonitorEnter(watch_ev_monitor);
 
-    if (watch_ev && isThreadExpected(jvmti_env, thr)) {
-        printf("#### JVMTI_EVENT_NATIVE_METHOD_BIND occured ####\n");
-        gen_ev++;
+    if (watch_ev) {
+        // we are interested only in events on the test thread and VMThread.
+        // In case of VMThread we most likely get crash (VMThread is not a Java Thread),
+        // but lets check GetThreadInfo - it returns error for non-Java threads.
+        if (env->IsSameObject(test_thread, thr)) {
+            printf("#### JVMTI_EVENT_NATIVE_METHOD_BIND occured on test thread ####\n");
+            gen_ev++;
+        } else {
+            jvmtiThreadInfo inf;
+            jvmtiError err = jvmti_env->GetThreadInfo(thr, &inf);
+            if (err != JVMTI_ERROR_NONE) {
+                printf("#### JVMTI_EVENT_NATIVE_METHOD_BIND: Failed to get thread info: %s (%d) ####\n",
+                    TranslateError(err), err);
+                result = STATUS_FAILED;
+            } else {
+                printf("got JVMTI_EVENT_NATIVE_METHOD_BIND event on thread '%s', ignoring", inf.name);
+                jvmti_env->Deallocate((unsigned char *)inf.name);
+                if (inf.thread_group != NULL) {
+                    env->DeleteLocalRef(inf.thread_group);
+                }
+                if (inf.context_class_loader != NULL) {
+                    env->DeleteLocalRef(inf.context_class_loader);
+                }
+            }
+        }
     }
 
     jvmti->RawMonitorExit(watch_ev_monitor);
@@ -153,7 +189,7 @@ Java_nsk_jvmti_RedefineClasses_redefclass031_makeRedefinition(JNIEnv *env,
     classDef.class_byte_count = env->GetArrayLength(classBytes);
     classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);
 
-    set_watch_ev(1); /* watch JVMTI events */
+    set_watch_ev(env, 1); /* watch JVMTI events */
 
     if (vrb == 1)
         printf(">>>>>>>> Invoke RedefineClasses():\n\tnew class byte count=%d\n",
@@ -168,7 +204,7 @@ Java_nsk_jvmti_RedefineClasses_redefclass031_makeRedefinition(JNIEnv *env,
     else if (vrb == 1)
         printf("Check #1 PASSED: RedefineClasses() is successfully done\n");
 
-    set_watch_ev(0); /* again ignore JVMTI events */
+    set_watch_ev(env, 0); /* again ignore JVMTI events */
 
     if (gen_ev) {
         printf("TEST FAILED: %d unexpected JVMTI events were generated by the function RedefineClasses()\n",